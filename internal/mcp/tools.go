package mcp

import "strings"

func allTools() []ToolDefinition {
	return []ToolDefinition{
		{
			Name:        "myProfile",
			Description: "Return the current connection's member_id (auto-generated by server). Use this for debugging or referencing a specific member.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like). If provided, the server will treat this call as coming from that session."),
				required("session_id"),
			),
		},
		{
			Name:        "swarmNow",
			Description: "Return the server current time for clock alignment.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				required("session_id"),
			),
		},
		// === Issue / Task (default collaboration model) ===
		{
			Name:        "listIssues",
			Description: "List all disseminated issues (the shared issue pool).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("status", "string", "Filter by issue status: open|in_progress|done|canceled|all (default all)."),
				prop("subject_contains", "string", "Case-insensitive substring filter on subject."),
				prop("offset", "integer", "Offset for pagination (default 0)."),
				prop("limit", "integer", "Limit for pagination (default 50; max 200)."),
				prop("sort_by", "string", "Sort field: created_at|updated_at (default created_at)."),
				prop("sort_order", "string", "Sort order: asc|desc (default desc)."),
			),
		},
		{
			Name:        "listOpenedIssues",
			Description: "List only opened issues (status=open). This is a safer default for models to avoid forgetting status filters.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
			),
		},
		{
			Name:        "waitIssues",
			Description: "Block until at least one issue matching status exists. Returns immediately if issues exist, otherwise waits.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("status", "string", "Filter by status: open|in_progress|done|canceled (default open)."),
				prop("timeout_sec", "integer", "Long-poll timeout seconds (default 3600)."),
				prop("limit", "integer", "Max issues to return (default 50)."),
				required("session_id"),
			),
		},
		{
			Name:        "waitIssueTasks",
			Description: "Block until at least one task matching status exists under an issue. Returns immediately if tasks exist, otherwise waits.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("status", "string", "Filter by status: open|in_progress|submitted|done|blocked|canceled (default open)."),
				prop("timeout_sec", "integer", "Long-poll timeout seconds (default 3600)."),
				prop("limit", "integer", "Max tasks to return (default 50)."),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "getIssue",
			Description: "Get an issue by id.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "closeIssue",
			Description: "Close an issue (sets status=done). Requires all tasks under the issue to be done.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("summary", "string", "Optional close summary"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "reopenIssue",
			Description: "Reopen an issue (sets status=open). Only allowed when status is done/canceled.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("summary", "string", "Optional reopen summary"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "submitDelivery",
			Description: "Lead submits a delivery for an issue and blocks until an acceptor reviews it (approved/rejected).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("summary", "string", "Delivery summary (required)."),
				propObject(
					"artifacts",
					"Structured delivery artifacts (required).",
					obj(
						propEnum("test_result", []string{"passed", "failed"}, "Test result (required)."),
						prop("test_cases", "array", "Test cases/commands executed (required)."),
						prop("changed_files", "array", "Key changed files (required)."),
						prop("reviewed_refs", "array", "Key refs the acceptor should review (required)."),
						prop("test_output", "string", "Trimmed test output (optional)."),
						prop("known_risks", "string", "Known risks/boundaries (optional)."),
						required("test_result", "test_cases", "changed_files", "reviewed_refs"),
					),
				),
				prop("refs", "string", "Optional references (links/paths)."),
				prop("timeout_sec", "integer", "Max seconds to wait for acceptance review (default 3600)."),
				required("session_id", "issue_id", "summary", "artifacts"),
			),
		},
		{
			Name:        "claimDelivery",
			Description: "Claim a delivery (move from open to in_review) for exclusive review.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("delivery_id", "string", "Delivery ID"),
				prop("extend_sec", "integer", "Seconds to extend (default: configured delivery TTL)."),
				required("session_id", "delivery_id"),
			),
		},
		{
			Name:        "extendDeliveryLease",
			Description: "Extend a delivery lease (续约) to prevent it from being auto-reopened when expired.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("delivery_id", "string", "Delivery ID"),
				prop("extend_sec", "integer", "Seconds to extend (default: configured delivery TTL)."),
				required("session_id", "delivery_id"),
			),
		},
		{
			Name:        "reviewDelivery",
			Description: "Acceptor reviews a claimed delivery. verdict=approved|rejected. Only the claimant can review.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("delivery_id", "string", "Delivery ID"),
				prop("verdict", "string", "approved|rejected"),
				prop("feedback", "string", "Feedback content (optional)."),
				prop("refs", "string", "Optional references."),
				required("session_id", "delivery_id", "verdict"),
			),
		},
		{
			Name:        "getDelivery",
			Description: "Get a delivery by id.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("delivery_id", "string", "Delivery ID"),
				required("session_id", "delivery_id"),
			),
		},
		{
			Name:        "listDeliveries",
			Description: "List deliveries, with optional filters/pagination/sorting.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("status", "string", "Filter by status: open|in_review|approved|rejected|all (default all)."),
				prop("issue_id", "string", "Filter by issue_id (exact match)."),
				prop("delivered_by", "string", "Filter by delivered_by (exact match)."),
				prop("reviewed_by", "string", "Filter by reviewed_by (exact match)."),
				prop("offset", "integer", "Offset for pagination (default 0)."),
				prop("limit", "integer", "Limit for pagination (default 50; max 200)."),
			),
		},
		{
			Name:        "listOpenedDeliveries",
			Description: "List only opened deliveries (status=open). This is a safer default for models to avoid forgetting status filters.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
			),
		},
		{
			Name:        "waitDeliveries",
			Description: "Block until at least one delivery matching status exists. Returns immediately if deliveries exist, otherwise waits.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("status", "string", "Filter by status: open|in_review|approved|rejected (default open)."),
				prop("timeout_sec", "integer", "Long-poll timeout seconds (default 3600)."),
				prop("limit", "integer", "Max deliveries to return (default 50)."),
				required("session_id"),
			),
		},
		{
			Name:        "getIssueAcceptanceBundle",
			Description: "Get a full acceptance bundle for an issue: issue details, all tasks, all issue/task docs content, and the issue event log.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "extendIssueLease",
			Description: "Extend an issue lease (续约) to prevent it from being auto-canceled when expired.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("extend_sec", "integer", "Seconds to extend (default: configured issue TTL)."),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "extendIssueTaskLease",
			Description: "Extend an issue task lease (续约) to prevent it from being auto-reopened when expired.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("extend_sec", "integer", "Seconds to extend (default: configured task TTL)."),
				required("session_id", "issue_id", "task_id"),
			),
		},
		{
			Name:        "createIssue",
			Description: "Create a new issue (the main problem owned by the lead window).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("subject", "string", "Issue title"),
				prop("description", "string", "Issue background / goal"),
				propObject(
					"user_issue_doc",
					"User-provided issue document (required).",
					obj(
						prop("name", "string", "Doc name (without extension)"),
						prop("content", "string", "Doc content (markdown)"),
						required("name", "content"),
					),
				),
				propObject(
					"lead_issue_doc",
					"Lead-prepared issue document (required). Typically: refined context, assumptions, decisions, plan.",
					obj(
						prop("name", "string", "Doc name (without extension)"),
						prop("content", "string", "Doc content (markdown)"),
						required("name", "content"),
					),
				),
				propArrayOfObject(
					"user_other_docs",
					"Optional additional user docs (e.g. API docs, module docs).",
					obj(
						prop("name", "string", "Doc name (without extension)"),
						prop("content", "string", "Doc content (markdown)"),
						required("name", "content"),
					),
				),
				prop("shared_doc_paths", "array", "Shared docs paths (e.g. docs/shared/xxx.md) for global context"),
				prop("project_doc_paths", "array", "Project docs paths written by human (repo paths or external paths)"),
				required("session_id", "subject", "user_issue_doc", "lead_issue_doc"),
			),
		},
		{
			Name:        "updateIssueDocPaths",
			Description: "Update issue doc paths (shared_doc_paths / project_doc_paths) after issue creation.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("shared_doc_paths", "array", "Shared docs paths"),
				prop("project_doc_paths", "array", "Project docs paths"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "createIssueTask",
			Description: "Create a task under an issue. Tasks are the work items workers will claim and submit.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("subject", "string", "Task title"),
				prop("description", "string", "Task description / requirements"),
				propEnum("difficulty", []string{"easy", "medium", "focus"}, "Task difficulty (required)."),
				prop("context_task_ids", "array", "Optional context task IDs for additional background."),
				prop("suggested_files", "array", "Files likely to be modified"),
				prop("labels", "array", "Labels"),
				prop("doc_paths", "array", "Docs paths providing context for this task (shared/issue/task docs)"),
				prop("points", "integer", "Difficulty points for marketplace-style task grading"),
				propObject(
					"spec",
					"Task spec (required): goal, rules, constraints, conventions, acceptance criteria.",
					obj(
						prop("name", "string", "Spec doc name (without extension). Workers will read by this name."),
						prop("split_from", "string", "Which original issue point this task is split from (required)."),
						prop("split_reason", "string", "Why split this task (required). Forces lead to provide reasoning."),
						prop("impact_scope", "string", "Impact scope / affected areas and notes (required)."),
						prop("context_task_ids", "array", "Optional context task IDs for additional background."),
						prop("goal", "string", "Goal / scope"),
						prop("rules", "string", "Rules / behavior"),
						prop("constraints", "string", "Constraints"),
						prop("conventions", "string", "Conventions / agreements"),
						prop("acceptance", "string", "Acceptance criteria / DoD"),
						required("name", "split_from", "split_reason", "impact_scope", "goal", "rules", "constraints", "conventions", "acceptance"),
					),
				),
				required(
					"session_id",
					"issue_id",
					"subject",
					"difficulty",
					"spec",
				),
			),
		},
		{
			Name:        "claimIssueTask",
			Description: "Claim an open task under an issue. The claimant defaults to the current window (member_id).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("next_step_token", "string", "Optional token for claiming a reserved task (minted by getNextStepToken and attached by reviewIssueTask)."),
				required("session_id", "issue_id", "task_id"),
			),
		},
		{
			Name:        "submitIssueTask",
			Description: "Submit work result for a task (moves to submitted) and block until lead reviews/resolves it (or timeout).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				propObject(
					"artifacts",
					"Worker submission artifacts (required). Heavy, structured data for lead review.",
					obj(
						prop("summary", "string", "Short submission summary"),
						prop("changed_files", "array", "Changed files (relative paths)"),
						prop("diff", "string", "Optional unified diff or patch excerpt"),
						prop("links", "array", "Optional links (PR, diff, docs, logs)"),
						prop("test_cases", "array", "Test cases/commands executed (required)."),
						prop("test_result", "string", "Test result summary (required)."),
						prop("test_output", "string", "Raw/trimmed test output content (required)."),
						required("summary", "changed_files", "test_cases", "test_result", "test_output"),
					),
				),
				required("session_id", "issue_id", "task_id", "artifacts"),
			),
		},
		{
			Name:        "reviewIssueTask",
			Description: "Lead reviews a submitted task. verdict=approved|rejected. If rejected, task goes back to in_progress.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("verdict", "string", "approved|rejected"),
				prop("feedback", "string", "Feedback if rejected (or summary if approved)"),
				propIntEnum("completion_score", []int{1, 2, 5}, "Completion score for this task (required). 1|2|5"),
				propObject(
					"artifacts",
					"Lead review artifacts (required). Must explicitly reference what was reviewed.",
					obj(
						prop("review_summary", "string", "Review summary"),
						prop("reviewed_refs", "array", "Reviewed refs (paths/links/hashes)"),
						required("review_summary", "reviewed_refs"),
					),
				),
				propArrayOfObject(
					"feedback_details",
					"Structured review feedback details (required).",
					obj(
						propEnum("dimension", []string{"correctness", "security", "performance", "maintainability", "style", "test", "docs"}, "Feedback dimension"),
						propEnum("severity", []string{"info", "minor", "major", "critical"}, "Severity"),
						prop("file_path", "string", "Optional file path"),
						prop("line_range", "string", "Optional line range (e.g. 45-50)"),
						prop("content", "string", "Feedback content"),
						prop("suggestion", "string", "Optional suggestion"),
						required("dimension", "severity", "content"),
					),
				),
				prop("next_step_token", "string", "Token returned by getNextStepToken; must be provided to bind review -> next_step."),
				required("session_id", "issue_id", "task_id", "verdict", "completion_score", "artifacts", "feedback_details", "next_step_token"),
			),
		},
		{
			Name:        "getNextStepToken",
			Description: "Compute and mint a next_step_token for a specific worker based on issue points + completion score, then reserve the chosen task (if any).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Just-finished task ID (required). Used to account task points in dynamic assignment."),
				prop("worker_id", "string", "Target worker ID"),
				propIntEnum("completion_score", []int{1, 2, 5}, "Completion score for the just-finished task (required). 1|2|5"),
				required("session_id", "issue_id", "task_id", "worker_id", "completion_score"),
			),
		},
		{
			Name:        "getIssueTask",
			Description: "Get a task under an issue.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				required("session_id", "issue_id", "task_id"),
			),
		},
		{
			Name:        "listIssueTasks",
			Description: "List tasks under an issue, with optional filters/pagination/sorting.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("status", "string", "Filter by status: open|in_progress|submitted|done|blocked|canceled|all (default all)."),
				prop("subject_contains", "string", "Case-insensitive substring filter on subject."),
				prop("claimed_by", "string", "Filter by claimed_by (exact match)."),
				prop("submitter", "string", "Filter by submitter (exact match)."),
				prop("offset", "integer", "Offset for pagination (default 0)."),
				prop("limit", "integer", "Limit for pagination (default 50; max 200)."),
				prop("sort_by", "string", "Sort field: created_at|updated_at|points (default created_at)."),
				prop("sort_order", "string", "Sort order: asc|desc (default desc)."),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "listIssueOpenedTasks",
			Description: "List only opened tasks (status=open) under a specific issue. This is a safer default for models to avoid forgetting status filters.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "waitIssueTaskEvents",
			Description: "Signals-only long-poll wait for issue events after a given seq. Returns only: (1) worker question/blocker messages, (2) task submitted events. Ignores other events while hanging. This is the lead window's select-like mechanism.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "askIssueTask",
			Description: "Worker asks a question/blocker for a task and blocks until lead replies (kind=reply) or timeout.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("kind", "string", "question|blocker (default question)"),
				prop("content", "string", "Question/blocker content"),
				prop("refs", "string", "Optional references"),
				prop("timeout_sec", "integer", "Max seconds to wait for a reply (default 3600)"),
				required("session_id", "issue_id", "task_id", "content"),
			),
		},
		{
			Name:        "postIssueTaskMessage",
			Description: "Post a task message event for lead to review (e.g. question/blocker/feedback). Will be returned by waitIssueTaskEvents.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("kind", "string", "Message kind: question|blocker|feedback|progress|message"),
				prop("content", "string", "Message content"),
				prop("refs", "string", "Optional references"),
				required("session_id", "issue_id", "task_id", "content"),
			),
		},
		{
			Name:        "replyIssueTaskMessage",
			Description: "Lead replies to a task message (kind=reply). Will be returned by waitIssueTaskEvents.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("content", "string", "Reply content"),
				prop("refs", "string", "Optional references"),
				required("session_id", "issue_id", "task_id", "content"),
			),
		},
		// === Workers ===
		{
			Name:        "registerWorker",
			Description: "Register current window member_id as a worker identity (usually auto-called on claimIssueTask).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("worker_id", "string", "Worker ID (optional; defaults to current member_id)"),
				required("session_id"),
			),
		},
		{
			Name:        "listWorkers",
			Description: "List all registered workers.",
			InputSchema: obj(
				prop("session_id", "string", "Session id (cookie-like)."),
				required("session_id"),
			),
		},
		{
			Name:        "getWorker",
			Description: "Get a worker by id.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("worker_id", "string", "Worker ID"),
				required("session_id", "worker_id"),
			),
		},
		// === Docs Library ===
		{
			Name:        "writeSharedDoc",
			Description: "Write a shared doc into docs library (shared across all issues).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("name", "string", "Doc name (without extension)"),
				prop("content", "string", "Doc content (markdown)"),
				required("session_id", "name"),
			),
		},
		{
			Name:        "readSharedDoc",
			Description: "Read a shared doc from docs library.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("name", "string", "Doc name (without extension)"),
				required("session_id", "name"),
			),
		},
		{
			Name:        "listSharedDocs",
			Description: "List shared docs.",
			InputSchema: obj(
				prop("session_id", "string", "Session id (cookie-like)."),
				required("session_id"),
			),
		},
		{
			Name:        "writeIssueDoc",
			Description: "Write a doc under an issue.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("name", "string", "Doc name (without extension)"),
				prop("content", "string", "Doc content (markdown)"),
				required("session_id", "issue_id", "name"),
			),
		},
		{
			Name:        "readIssueDoc",
			Description: "Read a doc under an issue.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("name", "string", "Doc name (without extension)"),
				required("session_id", "issue_id", "name"),
			),
		},
		{
			Name:        "listIssueDocs",
			Description: "List docs under an issue.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "writeTaskDoc",
			Description: "Write a doc under a task.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("name", "string", "Doc name (without extension)"),
				prop("content", "string", "Doc content (markdown)"),
				required("session_id", "issue_id", "task_id", "name"),
			),
		},
		{
			Name:        "readTaskDoc",
			Description: "Read a doc under a task.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("name", "string", "Doc name (without extension)"),
				required("session_id", "issue_id", "task_id", "name"),
			),
		},
		{
			Name:        "listTaskDocs",
			Description: "List docs under a task.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				required("session_id", "issue_id", "task_id"),
			),
		},
		// === File Lock ===
		{
			Name:        "lockFiles",
			Description: "Acquire lease-based locks on one or more files. MUST be called before modifying any file. Files are locked atomically (all-or-nothing). If a file is already locked by another owner, waits up to wait_sec then fails. Heartbeat must be called every 30s to keep the lock alive.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("task_id", "string", "Associated task ID"),
				prop("owner", "string", "Lock owner (optional; defaults to current connection member_id)"),
				prop("files", "array", "List of file paths to lock (relative to repo root)"),
				prop("ttl_sec", "integer", "Lock TTL in seconds (default 120)"),
				prop("wait_sec", "integer", "Max wait time if lock is held (default 60)"),
				required("session_id", "files"),
			),
		},
		{
			Name:        "heartbeat",
			Description: "Extend the TTL of an active lease. Must be called every 30 seconds while holding a lock.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("lease_id", "string", "Lease ID returned by lockFiles"),
				prop("extend_sec", "integer", "Seconds to extend (default 120)"),
				required("session_id", "lease_id"),
			),
		},
		{
			Name:        "unlock",
			Description: "Release a lease and all its file locks. MUST be called after finishing file modifications.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("lease_id", "string", "Lease ID to release"),
				required("session_id", "lease_id"),
			),
		},
		{
			Name:        "listLocks",
			Description: "List active file locks, optionally filtered by owner or files.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("owner", "string", "Filter by owner"),
				prop("files", "array", "Filter by file paths"),
				required("session_id"),
			),
		},
		{
			Name:        "forceUnlock",
			Description: "Forcefully release a lease (Leader only). Use when a lock is stuck or owner is unresponsive.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("lease_id", "string", "Lease ID to force release"),
				prop("reason", "string", "Reason for force unlock (required for audit)"),
				required("session_id", "lease_id", "reason"),
			),
		},
	}
}

// allToolsForRole returns a role-scoped tool list.
// It does NOT delete tools from the codebase; it only controls exposure for a specific MCP binary.
func allToolsForRole(role string) []ToolDefinition {
	base := allTools()
	allowed := toolAllowSetForRole(role)
	if allowed == nil {
		// Unknown role: expose everything (useful for local debugging).
		return base
	}
	out := make([]ToolDefinition, 0, len(base))
	for _, t := range base {
		if allowed[t.Name] {
			out = append(out, t)
		}
	}
	return out
}

func toolAllowedForRole(role string, toolName string) bool {
	allowed := toolAllowSetForRole(role)
	if allowed == nil {
		return true
	}
	return allowed[toolName]
}

func toolAllowSetForRole(role string) map[string]bool {
	// Common tools: keep this minimal to avoid tool-surface bloat across roles.
	// Everything else should be explicitly allowed per role.
	common := map[string]bool{
		"myProfile": true,
		"swarmNow":  true,

		// Docs read/list are safe defaults for context recovery.
		"readSharedDoc":  true,
		"listSharedDocs": true,
		"readIssueDoc":   true,
		"listIssueDocs":  true,
		"readTaskDoc":    true,
		"listTaskDocs":   true,
	}

	switch strings.TrimSpace(role) {
	case "lead":
		allowed := cloneAllowSet(common)

		// Lead must be able to create/review tasks and submit deliveries.
		// Avoid exposing "worker execution" and "acceptance" tools.
		allowed["listIssues"] = true
		allowed["listOpenedIssues"] = true
		allowed["getIssue"] = true
		allowed["closeIssue"] = true
		allowed["reopenIssue"] = true
		allowed["extendIssueLease"] = true

		// Issue doc management
		allowed["writeIssueDoc"] = true
		allowed["updateIssueDocPaths"] = true

		// Task management
		allowed["createIssue"] = true
		allowed["createIssueTask"] = true
		allowed["getIssueTask"] = true
		allowed["listIssueTasks"] = true
		allowed["listIssueOpenedTasks"] = true
		allowed["reviewIssueTask"] = true
		allowed["getNextStepToken"] = true

		// Lead event loop
		allowed["waitIssueTaskEvents"] = true
		allowed["replyIssueTaskMessage"] = true

		// Worker directory (lead needs worker_id for getNextStepToken)
		allowed["listWorkers"] = true

		// Lock admin (lead can force-unlock stuck worker locks)
		allowed["forceUnlock"] = true

		// Delivery submission (lead submits; acceptor reviews).
		allowed["submitDelivery"] = true
		return allowed
	case "worker":
		allowed := cloneAllowSet(common)

		// Worker discovery tools: workers need to find open issues/tasks to claim.
		allowed["listIssues"] = true
		allowed["listOpenedIssues"] = true
		allowed["waitIssues"] = true
		allowed["listIssueTasks"] = true
		allowed["listIssueOpenedTasks"] = true
		allowed["waitIssueTasks"] = true

		// Worker operates on explicit issue_id/task_id once claimed.
		allowed["getIssue"] = true
		allowed["getIssueTask"] = true

		// Docs write (worker may attach task deliverables as docs)
		allowed["writeTaskDoc"] = true

		// Locks (worker edits code)
		allowed["lockFiles"] = true
		allowed["heartbeat"] = true
		allowed["unlock"] = true
		allowed["listLocks"] = true

		// Worker directory
		allowed["registerWorker"] = true

		// Core worker actions
		allowed["claimIssueTask"] = true
		allowed["submitIssueTask"] = true
		allowed["askIssueTask"] = true
		allowed["postIssueTaskMessage"] = true
		return allowed
	case "acceptor":
		allowed := cloneAllowSet(common)

		// Minimal read-only context for review
		allowed["getIssue"] = true
		allowed["getIssueTask"] = true
		allowed["getIssueAcceptanceBundle"] = true

		// Delivery / acceptance
		allowed["getDelivery"] = true
		allowed["listDeliveries"] = true
		allowed["listOpenedDeliveries"] = true
		allowed["waitDeliveries"] = true
		allowed["claimDelivery"] = true
		allowed["extendDeliveryLease"] = true
		allowed["reviewDelivery"] = true
		return allowed
	default:
		return nil
	}
}

func cloneAllowSet(in map[string]bool) map[string]bool {
	out := make(map[string]bool, len(in))
	for k, v := range in {
		out[k] = v
	}
	return out
}

// Schema builder helpers
func obj(parts ...map[string]any) map[string]any {
	result := map[string]any{"type": "object", "properties": map[string]any{}}
	for _, p := range parts {
		if req, ok := p["__required"]; ok {
			result["required"] = req
		} else {
			for k, v := range p {
				result["properties"].(map[string]any)[k] = v
			}
		}
	}
	return result
}

func prop(name, typ, desc string) map[string]any {
	p := map[string]any{"type": typ, "description": desc}
	if typ == "array" {
		p["items"] = map[string]any{"type": "string"}
	}
	return map[string]any{name: p}
}

func propObject(name, desc string, schema map[string]any) map[string]any {
	s := map[string]any{"type": "object", "description": desc}
	for k, v := range schema {
		s[k] = v
	}
	return map[string]any{name: s}
}

func propArrayOfObject(name, desc string, itemSchema map[string]any) map[string]any {
	s := map[string]any{"type": "array", "description": desc}
	s["items"] = itemSchema
	return map[string]any{name: s}
}

func propEnum(name string, values []string, desc string) map[string]any {
	return map[string]any{name: map[string]any{"type": "string", "enum": values, "description": desc}}
}

func propIntEnum(name string, values []int, desc string) map[string]any {
	arr := make([]any, 0, len(values))
	for _, v := range values {
		arr = append(arr, v)
	}
	return map[string]any{name: map[string]any{"type": "integer", "enum": arr, "description": desc}}
}

func required(names ...string) map[string]any {
	return map[string]any{"__required": names}
}
