package mcp

func allTools() []ToolDefinition {
	return []ToolDefinition{
		{
			Name:        "whoAmI",
			Description: "Return the current connection's member_id (auto-generated by server). Use this for debugging or referencing a specific member.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like). If provided, the server will treat this call as coming from that session."),
				required("session_id"),
			),
		},
		{
			Name:        "swarmNow",
			Description: "Return the server current time for clock alignment.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				required("session_id"),
			),
		},
		{
			Name:        "openSession",
			Description: "Open a new logical session and return a session_id + member_id. Pass session_id to subsequent tool calls to isolate windows even when the MCP server process is shared.",
			InputSchema: obj(),
		},
		// === Issue / Task (default collaboration model) ===
		{
			Name:        "listIssues",
			Description: "List all disseminated issues (the shared issue pool).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
			),
		},
		{
			Name:        "waitIssues",
			Description: "Long-poll wait for issue pool changes (e.g. wait until at least one issue exists).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("after_count", "integer", "Block until issue count becomes > after_count. If omitted or <0, uses current count (tail)."),
				prop("timeout_sec", "integer", "Long-poll timeout seconds (default 600)."),
				required("session_id"),
			),
		},
		{
			Name:        "waitIssueTasks",
			Description: "Long-poll wait for issue task pool changes (e.g. wait until at least one task exists under an issue).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("after_count", "integer", "Block until task count becomes > after_count. If omitted or <0, uses current count (tail)."),
				prop("timeout_sec", "integer", "Long-poll timeout seconds (default 600)."),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "getIssue",
			Description: "Get an issue by id.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "closeIssue",
			Description: "Close an issue (sets status=done). Requires all tasks under the issue to be done.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("summary", "string", "Optional close summary"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "extendIssueLease",
			Description: "Extend an issue lease (续约) to prevent it from being auto-canceled when expired.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("extend_sec", "integer", "Seconds to extend (default: configured issue TTL)."),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "extendIssueTaskLease",
			Description: "Extend an issue task lease (续约) to prevent it from being auto-reopened when expired.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("extend_sec", "integer", "Seconds to extend (default: configured task TTL)."),
				required("session_id", "issue_id", "task_id"),
			),
		},
		{
			Name:        "createIssue",
			Description: "Create a new issue (the main problem owned by the lead window).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("subject", "string", "Issue title"),
				prop("description", "string", "Issue background / goal"),
				propObject(
					"user_issue_doc",
					"User-provided issue document (required).",
					obj(
						prop("name", "string", "Doc name (without extension)"),
						prop("content", "string", "Doc content (markdown)"),
						required("name", "content"),
					),
				),
				propObject(
					"lead_issue_doc",
					"Lead-prepared issue document (required). Typically: refined context, assumptions, decisions, plan.",
					obj(
						prop("name", "string", "Doc name (without extension)"),
						prop("content", "string", "Doc content (markdown)"),
						required("name", "content"),
					),
				),
				propArrayOfObject(
					"user_other_docs",
					"Optional additional user docs (e.g. API docs, module docs).",
					obj(
						prop("name", "string", "Doc name (without extension)"),
						prop("content", "string", "Doc content (markdown)"),
						required("name", "content"),
					),
				),
				prop("shared_doc_paths", "array", "Shared docs paths (e.g. docs/shared/xxx.md) for global context"),
				prop("project_doc_paths", "array", "Project docs paths written by human (repo paths or external paths)"),
				required("session_id", "subject", "user_issue_doc", "lead_issue_doc"),
			),
		},
		{
			Name:        "updateIssueDocPaths",
			Description: "Update issue doc paths (shared_doc_paths / project_doc_paths) after issue creation.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("shared_doc_paths", "array", "Shared docs paths"),
				prop("project_doc_paths", "array", "Project docs paths"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "createIssueTask",
			Description: "Create a task under an issue. Tasks are the work items workers will claim and submit.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("subject", "string", "Task title"),
				prop("description", "string", "Task description / requirements"),
				propEnum("difficulty", []string{"easy", "medium", "focus"}, "Task difficulty (required)."),
				prop("context_task_ids", "array", "Optional context task IDs for additional background."),
				prop("suggested_files", "array", "Files likely to be modified"),
				prop("labels", "array", "Labels"),
				prop("doc_paths", "array", "Docs paths providing context for this task (shared/issue/task docs)"),
				prop("points", "integer", "Difficulty points for marketplace-style task grading"),
				propObject(
					"spec",
					"Task spec (required): goal, rules, constraints, conventions, acceptance criteria.",
					obj(
						prop("name", "string", "Spec doc name (without extension). Workers will read by this name."),
						prop("split_from", "string", "Which original issue point this task is split from (required)."),
						prop("split_reason", "string", "Why split this task (required). Forces lead to provide reasoning."),
						prop("impact_scope", "string", "Impact scope / affected areas and notes (required)."),
						prop("context_task_ids", "array", "Optional context task IDs for additional background."),
						prop("goal", "string", "Goal / scope"),
						prop("rules", "string", "Rules / behavior"),
						prop("constraints", "string", "Constraints"),
						prop("conventions", "string", "Conventions / agreements"),
						prop("acceptance", "string", "Acceptance criteria / DoD"),
						required("name", "split_from", "split_reason", "impact_scope", "goal", "rules", "constraints", "conventions", "acceptance"),
					),
				),
				required(
					"session_id",
					"issue_id",
					"subject",
					"difficulty",
					"spec",
				),
			),
		},
		{
			Name:        "claimIssueTask",
			Description: "Claim an open task under an issue. The claimant defaults to the current window (member_id).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("next_step_token", "string", "Optional token for claiming a reserved task (minted by getNextStepToken and attached by reviewIssueTask)."),
				required("session_id", "issue_id", "task_id"),
			),
		},
		{
			Name:        "submitIssueTask",
			Description: "Submit work result for a task (moves to submitted) and block until lead reviews/resolves it (or timeout).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				propObject(
					"artifacts",
					"Worker submission artifacts (required). Heavy, structured data for lead review.",
					obj(
						prop("summary", "string", "Short submission summary"),
						prop("changed_files", "array", "Changed files (relative paths)"),
						prop("diff", "string", "Optional unified diff or patch excerpt"),
						prop("links", "array", "Optional links (PR, diff, docs, logs)"),
						prop("test_cases", "array", "Test cases/commands executed (required)."),
						prop("test_result", "string", "Test result summary (required)."),
						prop("test_output", "string", "Raw/trimmed test output content (required)."),
						required("summary", "changed_files", "test_cases", "test_result", "test_output"),
					),
				),
				required("session_id", "issue_id", "task_id", "artifacts"),
			),
		},
		{
			Name:        "reviewIssueTask",
			Description: "Lead reviews a submitted task. verdict=approved|rejected. If rejected, task goes back to in_progress.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("verdict", "string", "approved|rejected"),
				prop("feedback", "string", "Feedback if rejected (or summary if approved)"),
				propIntEnum("completion_score", []int{1, 2, 5}, "Completion score for this task (required). 1|2|5"),
				propObject(
					"artifacts",
					"Lead review artifacts (required). Must explicitly reference what was reviewed.",
					obj(
						prop("review_summary", "string", "Review summary"),
						prop("reviewed_refs", "array", "Reviewed refs (paths/links/hashes)"),
						required("review_summary", "reviewed_refs"),
					),
				),
				propArrayOfObject(
					"feedback_details",
					"Structured review feedback details (required).",
					obj(
						propEnum("dimension", []string{"correctness", "security", "performance", "maintainability", "style", "test", "docs"}, "Feedback dimension"),
						propEnum("severity", []string{"info", "minor", "major", "critical"}, "Severity"),
						prop("file_path", "string", "Optional file path"),
						prop("line_range", "string", "Optional line range (e.g. 45-50)"),
						prop("content", "string", "Feedback content"),
						prop("suggestion", "string", "Optional suggestion"),
						required("dimension", "severity", "content"),
					),
				),
				prop("next_step_token", "string", "Token returned by getNextStepToken; must be provided to bind review -> next_step."),
				required("session_id", "issue_id", "task_id", "verdict", "completion_score", "artifacts", "feedback_details", "next_step_token"),
			),
		},
		{
			Name:        "getNextStepToken",
			Description: "Compute and mint a next_step_token for a specific worker based on issue points + completion score, then reserve the chosen task (if any).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Just-finished task ID (required). Used to account task points in dynamic assignment."),
				prop("worker_id", "string", "Target worker ID"),
				propIntEnum("completion_score", []int{1, 2, 5}, "Completion score for the just-finished task (required). 1|2|5"),
				required("session_id", "issue_id", "task_id", "worker_id", "completion_score"),
			),
		},
		{
			Name:        "getIssueTask",
			Description: "Get a task under an issue.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				required("session_id", "issue_id", "task_id"),
			),
		},
		{
			Name:        "listIssueTasks",
			Description: "List tasks under an issue, optionally filter by status.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("status", "string", "Filter by status"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "waitIssueTaskEvents",
			Description: "Signals-only long-poll wait for issue events after a given seq. Returns only: (1) worker question/blocker messages, (2) task submitted events. Ignores other events while hanging. This is the lead window's select-like mechanism.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "askIssueTask",
			Description: "Worker asks a question/blocker for a task and blocks until lead replies (kind=reply) or timeout. In strict mode, this is the preferred way to ask.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("kind", "string", "question|blocker (default question)"),
				prop("content", "string", "Question/blocker content"),
				prop("refs", "string", "Optional references"),
				prop("timeout_sec", "integer", "Max seconds to wait for a reply (default 600)"),
				required("session_id", "issue_id", "task_id", "content"),
			),
		},
		{
			Name:        "postIssueTaskMessage",
			Description: "Post a task message event for lead to review (e.g. question/blocker/feedback). Will be returned by waitIssueTaskEvents.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("kind", "string", "Message kind: question|blocker|feedback|progress|message"),
				prop("content", "string", "Message content"),
				prop("refs", "string", "Optional references"),
				required("session_id", "issue_id", "task_id", "content"),
			),
		},
		{
			Name:        "replyIssueTaskMessage",
			Description: "Lead replies to a task message (kind=reply). Will be returned by waitIssueTaskEvents.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("content", "string", "Reply content"),
				prop("refs", "string", "Optional references"),
				required("session_id", "issue_id", "task_id", "content"),
			),
		},
		// === Workers ===
		{
			Name:        "registerWorker",
			Description: "Register current window member_id as a worker identity (usually auto-called on claimIssueTask).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("worker_id", "string", "Worker ID (optional; defaults to current member_id)"),
				required("session_id"),
			),
		},
		{
			Name:        "listWorkers",
			Description: "List all registered workers.",
			InputSchema: obj(
				prop("session_id", "string", "Session id (cookie-like)."),
				required("session_id"),
			),
		},
		{
			Name:        "getWorker",
			Description: "Get a worker by id.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("worker_id", "string", "Worker ID"),
				required("session_id", "worker_id"),
			),
		},
		// === Docs Library ===
		{
			Name:        "writeSharedDoc",
			Description: "Write a shared doc into docs library (shared across all issues).",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("name", "string", "Doc name (without extension)"),
				prop("content", "string", "Doc content (markdown)"),
				required("session_id", "name"),
			),
		},
		{
			Name:        "readSharedDoc",
			Description: "Read a shared doc from docs library.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("name", "string", "Doc name (without extension)"),
				required("session_id", "name"),
			),
		},
		{
			Name:        "listSharedDocs",
			Description: "List shared docs.",
			InputSchema: obj(
				prop("session_id", "string", "Session id (cookie-like)."),
				required("session_id"),
			),
		},
		{
			Name:        "writeIssueDoc",
			Description: "Write a doc under an issue.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("name", "string", "Doc name (without extension)"),
				prop("content", "string", "Doc content (markdown)"),
				required("session_id", "issue_id", "name"),
			),
		},
		{
			Name:        "readIssueDoc",
			Description: "Read a doc under an issue.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("name", "string", "Doc name (without extension)"),
				required("session_id", "issue_id", "name"),
			),
		},
		{
			Name:        "listIssueDocs",
			Description: "List docs under an issue.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				required("session_id", "issue_id"),
			),
		},
		{
			Name:        "writeTaskDoc",
			Description: "Write a doc under a task.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("name", "string", "Doc name (without extension)"),
				prop("content", "string", "Doc content (markdown)"),
				required("session_id", "issue_id", "task_id", "name"),
			),
		},
		{
			Name:        "readTaskDoc",
			Description: "Read a doc under a task.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				prop("name", "string", "Doc name (without extension)"),
				required("session_id", "issue_id", "task_id", "name"),
			),
		},
		{
			Name:        "listTaskDocs",
			Description: "List docs under a task.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("issue_id", "string", "Issue ID"),
				prop("task_id", "string", "Task ID"),
				required("session_id", "issue_id", "task_id"),
			),
		},
		// === File Lock ===
		{
			Name:        "lockFiles",
			Description: "Acquire lease-based locks on one or more files. MUST be called before modifying any file. Files are locked atomically (all-or-nothing). If a file is already locked by another owner, waits up to wait_sec then fails. Heartbeat must be called every 30s to keep the lock alive.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("task_id", "string", "Associated task ID"),
				prop("owner", "string", "Lock owner (optional; defaults to current connection member_id)"),
				prop("files", "array", "List of file paths to lock (relative to repo root)"),
				prop("ttl_sec", "integer", "Lock TTL in seconds (default 120)"),
				prop("wait_sec", "integer", "Max wait time if lock is held (default 60)"),
				required("session_id", "files"),
			),
		},
		{
			Name:        "heartbeat",
			Description: "Extend the TTL of an active lease. Must be called every 30 seconds while holding a lock.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("lease_id", "string", "Lease ID returned by lockFiles"),
				prop("extend_sec", "integer", "Seconds to extend (default 120)"),
				required("session_id", "lease_id"),
			),
		},
		{
			Name:        "unlock",
			Description: "Release a lease and all its file locks. MUST be called after finishing file modifications.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("lease_id", "string", "Lease ID to release"),
				required("session_id", "lease_id"),
			),
		},
		{
			Name:        "listLocks",
			Description: "List active file locks, optionally filtered by owner or files.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("owner", "string", "Filter by owner"),
				prop("files", "array", "Filter by file paths"),
				required("session_id"),
			),
		},
		{
			Name:        "forceUnlock",
			Description: "Forcefully release a lease (Leader only). Use when a lock is stuck or owner is unresponsive.",
			InputSchema: obj(
				prop("session_id", "string", "Optional session id (cookie-like)."),
				prop("lease_id", "string", "Lease ID to force release"),
				prop("reason", "string", "Reason for force unlock (required for audit)"),
				required("session_id", "lease_id", "reason"),
			),
		},
	}
}

func allToolsStrict(strict bool) []ToolDefinition {
	tools := allTools()
	if !strict {
		return tools
	}

	// Strict mode: hide non-blocking ask primitives to encourage small worker models
	// to use blocking askIssueTask.
	blocked := map[string]bool{
		"postIssueTaskMessage": true,
	}

	out := make([]ToolDefinition, 0, len(tools))
	for _, t := range tools {
		if blocked[t.Name] {
			continue
		}
		out = append(out, t)
	}
	return out
}

// Schema builder helpers
func obj(parts ...map[string]any) map[string]any {
	result := map[string]any{"type": "object", "properties": map[string]any{}}
	for _, p := range parts {
		if req, ok := p["__required"]; ok {
			result["required"] = req
		} else {
			for k, v := range p {
				result["properties"].(map[string]any)[k] = v
			}
		}
	}
	return result
}

func prop(name, typ, desc string) map[string]any {
	p := map[string]any{"type": typ, "description": desc}
	if typ == "array" {
		p["items"] = map[string]any{"type": "string"}
	}
	return map[string]any{name: p}
}

func propObject(name, desc string, schema map[string]any) map[string]any {
	s := map[string]any{"type": "object", "description": desc}
	for k, v := range schema {
		s[k] = v
	}
	return map[string]any{name: s}
}

func propArrayOfObject(name, desc string, itemSchema map[string]any) map[string]any {
	s := map[string]any{"type": "array", "description": desc}
	s["items"] = itemSchema
	return map[string]any{name: s}
}

func propEnum(name string, values []string, desc string) map[string]any {
	return map[string]any{name: map[string]any{"type": "string", "enum": values, "description": desc}}
}

func propIntEnum(name string, values []int, desc string) map[string]any {
	arr := make([]any, 0, len(values))
	for _, v := range values {
		arr = append(arr, v)
	}
	return map[string]any{name: map[string]any{"type": "integer", "enum": arr, "description": desc}}
}

func required(names ...string) map[string]any {
	return map[string]any{"__required": names}
}
